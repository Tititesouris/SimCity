breed [houses house]
houses-own [
  electricityUsage ; Electricity usage in kWh
  electricityStored ; Current amount of electricity in the house in kW
  waterUsage ; Water usage in L/h
  waterStored ; Current amount of water in the house in L
  happiness ; Happiness of the house
  residents ; List of people living in the house
  residentsAtHome ; List of people currently in the house
]

to loadHouses
  file-open "houses.txt"
  while [not file-at-end?] [
    let :x file-read
    let :y file-read
    let :nbResidents file-read
    create-houses 1 [initHouse :x :y :nbResidents]
  ]
  file-close
end

to initHouse [:x :y :nbResidents]
  initResourceConsumer (3 + :nbResidents * 2) (:nbResidents * 1.5)
  set happiness 100
  setxy :x :y
  let :residence who
  hatch-persons :nbResidents [initPerson :residence]
  set residents persons with [residence = :residence]
  set residentsAtHome residents

  set size 2
  set color houseColor
  face one-of patches in-radius 1 with [pcolor = roadColor]
end

to updateHouse
  updateResourceConsumer
  
  updateHouseWarnings
  
  ifelse timeReleaseOffers <= time and time < timeLeaveHome [
    findJob
  ][
    ifelse time = timeLeaveHome [
      goWorking
    ][
      ifelse timeLeaveWork <= time and time < timeSleep [
        getHome
      ][
        if time = timeSleep [
          goSleep
        ]
      ]
    ]
  ]
  
  updateHouseHappiness
end

to updateHouseWarnings
  if time mod hourLength = 0 [
    let :target who
    let :warnings warnings with [target = :target]
    let :employementWarnings :warnings with [shape = warningEmployement]
    
    let :x xcor - 0.5 + (0.5 * (count :warnings))
    let :y ycor + 0.75
    let :importanceStart 3 * dayLength
    let :importanceStep dayLength
    
    let :longUnemployedResidents residents with [(employer = -1) and ((ticks - startUnemployed) > :importanceStart)]
    ifelse count :longUnemployedResidents > 0 [
      if not any? :employementWarnings [
        hatch-warnings 1 [initWarning :x :y warningEmployement :target :importanceStep]
      ]
    ][
      ask :employementWarnings [die]
    ]
  ]
end

to findJob
  let :unemployedResidents residents with [employer = -1]
  let :nbUnemployed count :unemployedResidents
  if :nbUnemployed > 0 [
    let offersAround offers in-radius 1.5
    ask offersAround [
      let :nbEmploying (min list nbOpenJobs :nbUnemployed)
      let :recruiter recruiter
      ask n-of :nbEmploying :unemployedResidents [set employer :recruiter set startEmployed ticks]
      acceptOffer :nbEmploying
    ]
  ]
end

to goWorking
  let :employedResidents residents with [employer != -1]
  let :nbEmployed count :employedResidents
  if :nbEmployed > 0 [
    let :reach timeLeaveWork - time - hourLength ; Can drive until 1h before work closes
    set residentsAtHome residents with [employer = -1]
    hatch-cars 1 [initCar xcor ycor :reach :employedResidents]
  ]
end

to getHome
  let :residence who
  if count residentsAtHome < count residents [
    let carsAround cars in-radius 1.5
    ask carsAround [
      let :droppedOffPassengers passengers with [residence = :residence]
      let :nbDroppedOff count :droppedOffPassengers
      ask myself [set residentsAtHome (turtle-set residentsAtHome :droppedOffPassengers)]
      dropOffPassengers :droppedOffPassengers
    ]
  ]
end

to goSleep
  set residentsAtHome residents
end

to updateHouseHappiness
  let :target who
  let :warnings warnings with [target = :target]
  set happiness 100 - 10 * (sum [importance] of :warnings)
end

to-report houseText
  report (word (count residents with [employer != -1]) "/" (count residentsAtHome) "/" (count residents))
end