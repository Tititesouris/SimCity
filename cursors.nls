breed [cursors cursor]
cursors-own [
  cursor-was-down? ; Whether or not the mouse button was down during the previous tick
  cursor-click-down? ; True only during the tick when the mouse button is pressed
  cursor-click-up? ; True only during the tick when the mouse button is released
  cursor-down? ; Whether or not the mouse button is down (same as mouse-down? but doesn't change mid-tick)
  correctColor ; Color of the cursor when it can interact
  incorrectColor ; Color of the cursor when it cannot interact
  tools ; Tools available
  activeTool ; Tool currently selected
  selectedPatch ; Patch selected. Different uses based on the active tool
]

to initCursor
  set cursor-was-down? false
  set correctColor green
  set incorrectColor red
  let :noneTool (list [[] -> cursorSelectIntersection] [[] -> doNothing] [[] -> doNothing] [[] -> setCorrectColor])
  let :roadTool (list [[] -> markSelectedPatch] [[] -> cursorRoadClickUp] [[] -> cursorRoadDown] [[] -> cursorRoadUp])
  let :houseTool (list [[] -> markSelectedPatch] [[] -> cursorHouseClickUp] [[] -> rectangleSelectionNextToRoads houses] [[] -> setCorrectColor])
  let :businessTool (list [[] -> markSelectedPatch] [[] -> cursorBusinessClickUp] [[] -> rectangleSelectionNextToRoads businesses] [[] -> setCorrectColor])
  let :powerplantTool (list [[] -> markSelectedPatch] [[] -> cursorPowerplantClickUp] [[] -> rectangleSelectionNextToRoads powerplants] [[] -> setCorrectColor])
  let :pumpTool (list [[] -> markSelectedPatch] [[] -> cursorPumpClickUp] [[] -> rectangleSelectionNextToRoads pumps] [[] -> setCorrectColor])
  set tools (list :noneTool :roadTool :houseTool :businessTool :powerplantTool :pumpTool)
  set activeTool 0
  set selectedPatch nobody
  
  set size 0.5
  set shape "gui cursor"
  set color incorrectColor
  set heading 0
end

to updateCursor
  setxy mouse-xcor mouse-ycor
  set cursor-down? mouse-down?
  set cursor-click-down? cursor-down? and (not cursor-was-down?)
  set cursor-click-up? (not cursor-down?) and cursor-was-down?
  
  let :guiElements guielements in-radius 1
  ifelse any? :guiElements [
    updateCursorGUIEvents :guiElements
  ][
    updateCursorEvents
  ]
  
  set cursor-was-down? cursor-down?
end

to updateCursorGUIEvents [:guiElements]
  if cursor-click-down? [
      ask :guiElements [
        ask other guielements [set color gray]
        set color blue
        ask myself [
          set activeTool [tool] of myself
          set shape [shape] of myself
        ]
      ]
    ]
end

to updateCursorEvents
  let :event [[:x :y] -> ]
  ifelse cursor-click-down? [
    set :event item 0 (item activeTool tools)
  ][
    ifelse cursor-click-up? [
      set :event item 1 (item activeTool tools)
    ][
      ifelse cursor-down? [
        set :event item 2 (item activeTool tools)
      ][
        set :event item 3 (item activeTool tools)
      ]
    ]
  ]
  (run :event xcor ycor)
end

to doNothing
end

to markSelectedPatch
  if color = correctColor [
    set selectedPatch patch-here
  ]
end

to rectangleSelectionNextToRoads [:breed]
  if selectedPatch != nobody [
    ask planners [die]
    let :patch patch-here
    let xA [pxcor] of selectedPatch
    let yA [pycor] of selectedPatch
    let xB [pxcor] of :patch
    let yB [pycor] of :patch
    
    let :validPatches patches with [
      pcolor = terrainColor and
      (min list xA xB) <= pxcor and pxcor <= (max list xA xB) and (min list yA yB) <= pycor and pycor <= (max list yA yB) and
      (any? patches with [pcolor = roadColor] in-radius 1) and
      (not any? turtles-here with [not member? breed (list betterlabels cursors)])
    ]
    ask :validPatches [sprout-planners 1 [initPlanners]]
  ]
end

to setCorrectColor
  set color correctColor
end

to cursorSelectIntersection
  ifelse selectedPatch = nobody [
    if any? intersections-here [
      set selectedPatch patch-here
      ask ([directions] of (one-of intersections-here)) [
        sprout-planners 1 [initPlanners]
      ]
    ]
  ][
    ifelse patch-here = selectedPatch [
      ask patch-here [
        ask intersections-here [die]
        if count planners > 0 [
          let :north any? planners-at 0 1
          let :east any? planners-at 1 0
          let :south any? planners-at 0 -1
          let :west any? planners-at -1 0
          sprout-intersections 1 [initIntersection pxcor pycor :north :east :south :west]
        ]
      ]
      ask planners [die]
      set selectedPatch nobody
    ][
      ask patch-here [
        if (distance [selectedPatch] of myself) <= 1 [
          ifelse any? planners-here [
            ask planners-here [die]
          ][
            sprout-planners 1 [initPlanners]
          ]
        ]
      ]
    ]
  ]
end

to cursorRoadClickUp
  if selectedPatch != nobody [
    if count planners > 1 [
      ask planners [
        ask patch-here [
          ask intersections-here [die]
          if pcolor != highwayColor [
            set pcolor roadColor
          ]
          
          let :roadPatches patches in-radius 1 with [(pcolor = roadColor or pcolor = highwayColor) and not any? planners-here]
          if any? :roadPatches [
            let :north (any? planners-at 0 1) or (member? (patch-at 0 1) :roadPatches)
            let :east (any? planners-at 1 0) or (member? (patch-at 1 0) :roadPatches)
            let :south (any? planners-at 0 -1) or (member? (patch-at 0 -1) :roadPatches)
            let :west (any? planners-at -1 0) or (member? (patch-at -1 0) :roadPatches)
            sprout-intersections 1 [initIntersection pxcor pycor :north :east :south :west]
          ]
        ]
      ]
    ]
    ask planners [die]
    set selectedPatch nobody
  ]
end

to cursorRoadDown
  if selectedPatch != nobody [
    ask planners [die]
    let :patch patch-here
    let xA [pxcor] of selectedPatch
    let yA [pycor] of selectedPatch
    let xB [pxcor] of :patch
    let yB [pycor] of :patch
    
    ifelse (abs (yB - yA)) <= (abs (xB - xA)) [
      ask patches with [pycor = yA and (min list xA xB) <= pxcor and pxcor <= (max list xA xB)] [sprout-planners 1 [initPlanners]]
    ][
      ask patches with [pxcor = xA and (min list yA yB) <= pycor and pycor <= (max list yA yB)] [sprout-planners 1 [initPlanners]]
    ]
  ]
end

to cursorRoadUp
  ifelse member? ([pcolor] of patch-here) (list roadColor highwayColor) [
    set color correctColor
  ][
    set color incorrectColor
  ]
end

to cursorHouseClickUp
  if selectedPatch != nobody [
    ask planners [
      hatch-houses 1 [initHouse xcor ycor 1]
    ]
    ask planners [die]
    set selectedPatch nobody
  ]
end

to cursorBusinessClickUp
  if selectedPatch != nobody [
    ask planners [
      hatch-businesses 1 [initBusiness xcor ycor 10]
    ]
    ask planners [die]
    set selectedPatch nobody
  ]
end

to cursorPowerplantClickUp
  if selectedPatch != nobody [
    ask planners [
      hatch-powerplants 1 [initPowerplant xcor ycor 100]
    ]
    ask planners [die]
    set selectedPatch nobody
  ]
end

to cursorPumpClickUp
  if selectedPatch != nobody [
    ask planners [
      hatch-pumps 1 [initPump xcor ycor 100]
    ]
    ask planners [die]
    set selectedPatch nobody
  ]
end